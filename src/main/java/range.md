Мы хотим, чтобы наш кодер не использовал нормализации до того момента, пока не зафиксируются старшие 8 бит числа,
 чтобы мы могли их сбросить в виде байта, не прибегая к побитовым операциям.
 После такого сброса старшего байта мы должны увеличить рабочий интервал соответственно в 2^8 раз.
 Значение нижней границы интервала при нормализации также будет сдвинуто на 8 бит влево.
 Поэтому максимальный размер range, при котором мы можем произвести нормализацию, скинув старший байт в файл,
  получается равен 2^(n-8). Так как мы заинтересованы в обеспечении максимальной точности вычислений, то
   мы должны выполнять нормализацию сразу же, как только появится такая возможность - когда размер интервала
   станет меньше или равен 2^(n-8), где n - разрядность нашего кодера (32).

Так как мы теперь знаем, что минимальный range, при котором мы продолжаем вычисления без выполнения нормализации,
равен 2^(n-8), то мы должны ограничить соответствующим образом суммарную величину накопленных значений встречаемости
символов алфавита - totalCount. Оно не должно быть больше MIN_RANGE, т.к. если оно превысит его, то это может привести
к ситуации, когда мы не сможем корректно закодировать очередной символ - границы интервала слипнутся, и дальнейшее
кодирование станет невозможным.

----------

Рассмотрим работу кодировщика при n=32.

0          half        top                     2^32
|__|__|__|__|__|__|__|__|.......................|

Начальный интервал - [0; top), top = 2^(n-1). Мы должны зарезервировать 1 бит для второй половинки большого интервала
для обработки переносов (ниже будет рассказано, почему). Мы хотим, чтобы наш кодер не нуждался в нормализации до того
момента, пока не зафиксируются старшие 8 бит числа, которое мы моделируем в процессе сжатия, представляя в виде
интервала [low, low+range). Эти 8 бит мы сбросим в выходной буфер, и нам не нужно будет заморачиваться с побитовым
выводом. После такого сброса мы должны иметь возможность увеличить рабочий интервал в 2^8 раз, чтобы не возникло
переполнения. Значение нижней границы интервала также будет сдвинуто на 8 бит влево. Из этих соображений мы получаем, что
максимальный размер range, при котором мы можем провести нормализацию, записав полученный байт в файл, равен
2^(n-1-8). Имеет смысл делать это сразу же, как только мы получаем такую возможность, так как при дальнейшем уменьшении
интервала у нас снижается точность вычислений, а значит, и степень сжатия.

Ок, мы выяснили, что мы можем кодировать символы без нормализации до тех пор, пока размер интервала > 2^(n-9).
Теперь становится актуальным вопрос - что же именно следует записать в выходной буфер ? В случае с арифметическим побитовым
кодированием при нормализации мы записывали 0, если рабочий интервал целиком был в левой части или 1, если рабочий
интервал был целиком в правой. Если же рабочий интервал проходил через середину, то мы выполняли нормализацию, не записывая
бит в файл, в ожидании того, что будущие вычисления уточнят расположение интервала. Теперь мы работаем с восьмибитными
блоками, и возникает справедливый вопрос - как обрабатывать аналогичные явления ? Если переноса нет, то очевидно, мы можем
просто взять старшие 8 бит числа low и вывести их в файл:

0          half        top                     2^32
|__|__|__|__|__|__|__|__|.......................|
\                      /
Здесь на самом деле не 8 промежутков, а 2^8. И если наш рабочий интервал находится целиком внутри одного из таких промежутков,
то мы можем без опасений записать старший байт в файл, поскольку он однозначно указывает на координаты числа в текущем
интервале. Если же рабочий интервал частично покрывает два соседних промежутка (частично, т.к. размер рабочего интервала
не больше размера промежутка), то у нас возникает перенос. Причем такой перенос может возникнуть в любом бите.
Но ведь так не хочется снова отслеживать биты отдельно ! Неужели вся идея идёт прахом и ничего нельзя сделать ?

Рассмотрим случай, в котором мы
не будем записывать 8 бит целиком, а будем работать с трехбитовыми блоками. Допустим, мы закодировали несколько символов,
и получили интервал, меньший 2^(n-1-3):

0          half        top                     2^32
|__|_+|+_|__|__|__|__|__|.......................|
     | |
    low|
   low+range-1

Мы видим, что low указывает на второй промежуток, и мы можем записать значение его старших 3 бит: 001.
Но мы знаем, что при дальнейшем уточнении число может оказаться в третьем промежутке, и тогда нам нужно
изменить 001 на 010 (прибавить единицу). Если наши опасения окажутся напрасными и число действительно будет
лежать во втором промежутке, то всё будет как надо. Если же при дальнейших вычислениях число окажется, что
наше предположение было неверно, то мы добавим единицу к числу и далее запишем нулевые значения (столько раз,
сколько мы выполняли нормализацию перед тем, как получили достоверную информацию о том, что значение
действительно находится справа от границы). Из-за переноса нам и нужен резерв от top до 2^32, так как
при нормализации текущие 2 соседних промежутка проецируются на весь диапазон 32-битных чисел:

  0          half        top                     2^32
  |__|_+|+_|__|__|__|__|__|.......................|
    /       \___
   /            \___________________
  /                                 \__________
 /                                             \
0                      top                     2^32
|_________________+_____|.........+.............|

Но размер рабочего интервала никогда не превысит top+1. Поэтому я обозначаю вторую часть интервала точками как
дополнительную, которая используется только для обработки переноса.

Если бы переноса не было, нам бы хватало диапазона от 0 до top:

    0          half        top                     2^32
    |++|__|__|__|__|__|__|__|.......................|
    /   \___
   /        \_____
  /               \_____
 /                      \
0                      top                     2^32
|____+________________+_|.......................|

Итак, нам осталось рассмотреть только 1 случай: когда low находится в крайнем промежутке слева от top:

0          half        top                     2^32
|__|__|__|__|__|__|__|_+|+......................|

Особенность этого случая в том, что все 8 старших бит low установлены в единицу, а значит, при переносе
этот байт должен повлиять ещё и на предшествующий ему байт в выходном потоке (увеличить на 1, сам при этом
приняв значение 0). По сути это аналог ситуации с условной записью бит при арифметическом кодировании,
только здесь размер интервала в 2^8 раза меньше, но условие одинаковое - рабочий интервал пересекает
середину и одновременно требует нормализации. Так что и действовать мы можем аналогично - добавлять
единицу к счётчику байт, записанных "условно", сбрасывая их в файл, как только мы можем уточнить
размещение интервала.