Мы хотим, чтобы наш кодер не использовал нормализации до того момента, пока не зафиксируются старшие 8 бит числа,
 чтобы мы могли их сбросить в виде байта, не прибегая к побитовым операциям.
 После такого сброса старшего байта мы должны увеличить рабочий интервал соответственно в 2^8 раз.
 Значение нижней границы интервала при нормализации также будет сдвинуто на 8 бит влево.
 Поэтому максимальный размер range, при котором мы можем произвести нормализацию, скинув старший байт в файл,
  получается равен 2^(n-8). Так как мы заинтересованы в обеспечении максимальной точности вычислений, то
   мы должны выполнять нормализацию сразу же, как только появится такая возможность - когда размер интервала
   станет меньше или равен 2^(n-8), где n - разрядность нашего кодера (32).

Так как мы теперь знаем, что минимальный range, при котором мы продолжаем вычисления без выполнения нормализации,
равен 2^(n-8), то мы должны ограничить соответствующим образом суммарную величину накопленных значений встречаемости
символов алфавита - totalCount. Оно не должно быть больше MIN_RANGE, т.к. если оно превысит его, то это может привести
к ситуации, когда мы не сможем корректно закодировать очередной символ - границы интервала слипнутся, и дальнейшее
кодирование станет невозможным.

---------

Ограничения при кодировании блоками по BITS_IN_BLOCK бит и разрядности кодера N бит:

MIN_RANGE = 2^(N-1-BITS_IN_BLOCK)
MAX_TOTAL_COUNT <= MIN_RANGE
ALPHABET_SIZE <= MAX_TOTAL_COUNT

Таким образом, делая разрядность кодера = 16, у нас остаётся только 2^7 на алфавит, чего не хватит даже
для кодирования всех байтов. И это притом, что для подсчёта встречаемости места не останется - только по единице на символ.
Поэтому нужно брать сразу 32 бита, в этом случае будет достаточный запас для подсчёта встречаемостей символов.

----------

Рассмотрим работу кодировщика при n=32.

0          half        top                     2^32
|__|__|__|__|__|__|__|__|.......................|

Начальный интервал - [0; top), top = 2^(n-1). Мы должны зарезервировать 1 бит для второй половинки большого интервала
для обработки переносов (ниже будет рассказано, почему). Мы хотим, чтобы наш кодер не нуждался в нормализации до того
момента, пока не зафиксируются старшие 8 бит числа, которое мы моделируем в процессе сжатия, представляя в виде
интервала [low, low+range). Эти 8 бит мы сбросим в выходной буфер, и нам не нужно будет заморачиваться с побитовым
выводом. После такого сброса мы должны иметь возможность увеличить рабочий интервал в 2^8 раз, чтобы не возникло
переполнения. Значение нижней границы интервала также будет сдвинуто на 8 бит влево. Из этих соображений мы получаем, что
максимальный размер range, при котором мы можем провести нормализацию, записав полученный байт в файл, равен
2^(n-1-8). Имеет смысл делать это сразу же, как только мы получаем такую возможность, так как при дальнейшем уменьшении
интервала у нас снижается точность вычислений, а значит, и степень сжатия.

Ок, мы выяснили, что мы можем кодировать символы без нормализации до тех пор, пока размер интервала > 2^(n-9).
Теперь становится актуальным вопрос - что же именно следует записать в выходной буфер ? В случае с арифметическим побитовым
кодированием при нормализации мы записывали 0, если рабочий интервал целиком был в левой части или 1, если рабочий
интервал был целиком в правой. Если же рабочий интервал проходил через середину, то мы выполняли нормализацию, не записывая
бит в файл, в ожидании того, что будущие вычисления уточнят расположение интервала. Теперь мы работаем с восьмибитными
блоками, и возникает справедливый вопрос - как обрабатывать аналогичные явления ? Если переноса нет, то очевидно, мы можем
просто взять старшие 8 бит числа low и вывести их в файл:

0          half        top                     2^32
|__|__|__|__|__|__|__|__|.......................|
\                      /
Здесь на самом деле не 8 промежутков, а 2^8. И если наш рабочий интервал находится целиком внутри одного из таких промежутков,
то мы можем без опасений записать старший байт в файл, поскольку он однозначно указывает на координаты числа в текущем
интервале. Если же рабочий интервал частично покрывает два соседних промежутка (частично, т.к. размер рабочего интервала
не больше размера промежутка), то у нас возникает перенос. Причем такой перенос может возникнуть в любом бите.
Но ведь так не хочется снова отслеживать биты отдельно ! Неужели вся идея идёт прахом и ничего нельзя сделать ?

Рассмотрим случай, в котором мы
не будем записывать 8 бит целиком, а будем работать с трехбитовыми блоками. Допустим, мы закодировали несколько символов,
и получили интервал, меньший 2^(n-1-3):

0          half        top                     2^32
|__|_+|+_|__|__|__|__|__|.......................|
     | |
    low|
   low+range-1

Мы видим, что low указывает на второй промежуток, и мы можем записать значение его старших 3 бит: 001.
Но мы знаем, что при дальнейшем уточнении число может оказаться в третьем промежутке, и тогда нам нужно
изменить 001 на 010 (прибавить единицу). Если наши опасения окажутся напрасными и число действительно будет
лежать во втором промежутке, то всё будет как надо. Если же при дальнейших вычислениях число окажется, что
наше предположение было неверно, то мы добавим единицу к числу и далее запишем нулевые значения (столько раз,
сколько мы выполняли нормализацию перед тем, как получили достоверную информацию о том, что значение
действительно находится справа от границы). Из-за переноса нам и нужен резерв от top до 2^32, так как
при нормализации текущие 2 соседних промежутка проецируются на весь диапазон 32-битных чисел:

  0          half        top                     2^32
  |__|_+|+_|__|__|__|__|__|.......................|
    /       \___
   /            \___________________
  /                                 \__________
 /                                             \
0                      top                     2^32
|_________________+_____|.........+.............|

Но размер рабочего интервала никогда не превысит top+1. Поэтому я обозначаю вторую часть интервала точками как
дополнительную, которая используется только для обработки переноса.

Если бы переноса не было, нам бы хватало диапазона от 0 до top:

    0          half        top                     2^32
    |++|__|__|__|__|__|__|__|.......................|
    /   \___
   /        \_____
  /               \_____
 /                      \
0                      top                     2^32
|____+________________+_|.......................|

Итак, нам осталось рассмотреть только 1 случай: когда low находится в крайнем промежутке слева от top:

0          half        top                     2^32
|__|__|__|__|__|__|__|_+|+......................|

Особенность этого случая в том, что все 8 старших бит low установлены в единицу, а значит, при переносе
этот байт должен повлиять ещё и на предшествующий ему байт в выходном потоке (увеличить на 1, сам при этом
приняв значение 0). По сути это аналог ситуации с условной записью бит при арифметическом кодировании,
только здесь размер интервала в 2^8 раза меньше, но условие одинаковое - рабочий интервал пересекает
середину и одновременно требует нормализации. Так что и действовать мы можем аналогично - добавлять
единицу к счётчику байт, записанных "условно", сбрасывая их в файл, как только мы можем уточнить
размещение интервала.

TODO : Далее описание псевдокода алгоритма

FAQ:

1) Почему можно отказаться от переноса и как это реализовано ?

Предположим, мы работаем в арифметическом кодере размерностью 8 бит.

 0         q       half       3q        top
 |_________|_________|_________|_________|

 |____ a ____|____ b ____|______ c ______|

Мы закодировали b:

 0         q       half       3q        top
 |_________|_++++++++|++++_____|_________|

 |____ a ____|____ b ____|______ c ______|

Далее возникает перенос, и мы знаем, что следующие биты, записанные в файл, будут либо
01111... либо 10000... (в зависимости от того, насколько долго будет продолжаться перенос).
Но декодеру для успешного определения символа b по текущему состоянию совсем не обязательно
знать точно, что будет дальше! Он на входе имеет число, старшие биты которого однозначно
указывают на то, что следующий символ - b. А дальше будет производиться нормализация,
так как она всегда выполняется после декодирования очередного символа. Поэтому мы можем себе
позволить в этом месте любые манипуляции с low и high, но только такие, при которых
новый рабочий интервал не выйдет за рамки текущих low и high. Почему такое ограничение ? Почему
мы не можем просто взять и перейти к абсолютно новому интервалу (например, вернуться к исходному) ?
Ведь эти операции мы будем делать синхронно в кодере и декодере. Дело в том, что текущее состояние
обязывает нас не выходить за область текущего интервала, т.к. если мы это сделаем, то при кодировании
следующих символов мы будем использовать область, уже недоступную нам, и кодер может записать координаты
нового интервала так, как будто первым символом был не `b`, а `a`:

 0         q       half       3q        top
 |_________|_++++++++|++++_____|_________|

Выполняем неправильное действие по увеличению интервала

 0         q       half       3q        top
 |_________|+++++++++|+++++++++|_________|

Кодируем далее символ `a`:

0         q       half       3q        top
 |_________|++++++___|_________|_________|

           |_ a _|_ b _|__ c __|

Декодер, увидев число, указывающее на такой диапазон, в качестве первого символа выведет `a` вместо `b`.

0         q       half       3q        top
 |_________|++++++___|_________|_________|
 |____ a ____|____ b ____|______ c ______|

Итак, мы пришли к выводу, что мы можем при нормализации уменьшать рабочий интервал принудительно,
избегая ситуаций с переносом. Плата за это - необходимость проводить дополнительные итерации нормализации,
добавляя биты, уточняющие наше искомое число, которых не было бы, если бы мы не уменьшали интервал.
Это уменьшает степень сжатия. И к сожалению, при арифметическом кодировании такой подход не очень хорош,
поскольку сжатие уменьшается существенно - около 9% на текстовых данных (книга "Война и мир"), и в
скорости выигрыша нет, т.к. дополнительные итерации нормализации с побитовым выводом съедают выгоду
от отказа от переноса. А вот в интервальном кодировании этот подход очень даже кстати.

2) Почему в случае отказа от переноса при интервальном кодировании потери несущественны,
 а при арифметическом - доходят до 9% ?

Потому что при кодировании битовыми блоками нормализация производится в M раз реже (M - кол-во битов в блоке,
в случае побайтового интервального кодирования - 8). И несмотря на то, что перенос может возникать в каждом
бите (как и в случае арифметического кодирования), в интервальном кодере мы не обрабатываем каждый такой
перенос, мы просто продолжаем вычисления до тех пор, пока точность позволяет нам это делать. Поэтому
большинство переносов обрабатывается автоматически. А тот перенос, который всё-таки может возникать
при нормализации, случается очень редко, и мы можем в этом случае пренебречь точностью ради выгоды
в скорости и простоте кода. Для подтверждения этих доводов можно попробовать модифицировать
арифметический кодер так, чтобы он избегал переноса принудительным сужением интервала в 1/8 случаев
переноса:

Arithmetic coding with carry
Source size 1473547 encoded size 896659 ratio 60,850383%

Arithmetic coding with carry in 7/8 cases, in 1/8 - carryness
Source size 1473547 encoded size 896750 ratio 60,856559%

Результаты по степени сжатия получаются небольшие - 0.05%. Примерно столько же теряет и интервальный кодер
при отказе от переноса, по данным изобретателя этой техники Дмитрия Субботина.

Оставшиеся вопросы:

1) Как реализуется принудительное уменьшение интервала в байтовом интервальном кодировании ?

2) Какими символами нужно закончить кодирование ?

После кодирования последнего символа (перед нормализацией) мы имеем интервал размером не более 2^23.
Минимальный размер интервала - 1 (это возможно для самого редко встречающегося символа). Так как все символы уже
закодированы, нам теперь необходимо уточнить наше число так, чтобы он указывал на одно из этого интервала.
Т.к. минимальный размер интервала - 1, то нам придется использовать 23 бита для указания точной координаты числа.
Если размер интервала большой, то может понадобиться меньше бит, но мы не будем заморачиваться микрооптимизациями.
Суть задачи - вывести число, гарантированно находящееся в последнем рабочем интервале, и обработать перенос,
если он был возможен до завершения кодирования:

  0          half        top                     2^32
  |__|_+|+_|__|__|__|__|__|.......................|
    /       \___
   /            \___________________
  /                                 \__________
 /                                             \
0                      top                     2^32
|_________________++++++|++++++++++.............|

Число low вполне удовлетворяет нашим требованиям, поэтому мы смотрим
1. Если low >= top, обрабатываем текущий перенос как свершившийся
2. Иначе обрабатываем текущий перенос как не произошедший
3. Сбрасываем 23 старших бита от 31-битного значения low в файл
   (можно сбросить 24 для ровного побайтового счёта, или все 31 бит)

3) Почему в приводимых примерах range coder'ов первый записываемый байт всегда 0 ? Ведь он лишний ?

Да, так всегда и получается, но это упрощает код нормализации, в неё не требуется производить проверку
на то, что один байт уже записан. Можно решить эту проблему дублированием кода цикла до первой нормализации.
Цикл кодирования начинается с интервала [0; top), поэтому первой всегда отработает ветка if ( low < top - MIN_RANGE - 1 ).

4) Как реализуется декодирование ?

