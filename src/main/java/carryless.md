Теперь рассмотрим оптимизацию в виде отказа от переноса в интервальном кодере. Мы хотим принудительно уменьшать интервал
перед нормализацией так, чтобы переноса не возникало никогда. Так как заморачиваться с переносом мы больше не хотим, мы
можем использовать не 31 бит в числе, а все 32. Теперь нужно разобраться с условием, при котором надо уменьшать интервал.
Нормализация у нас, как и раньше, будет производиться сдвигом на 8 бит влево:

0                                                                             2^32
|__|__|__|__|__|__|__|__|_ ... (всего 256 частей) ... _|__|__|__|__|__|__|__|__|

Любая такая часть при нормализации и отбрасывании старших битов (которые указывали на координаты этой части)
мапится на целый интервал [0; 2^32). Поэтому мы должны рассмотреть одну такую часть и
найти в ней условие, при котором может произойти перенос.

    0                                2^24
____|_________________________________|_____





"Hi, All!
Я тут подумал, что потери в 1% для арифметического кодера это все-таки слишком
много, и слегка его соптимизировал. Теперь он теряет всего где-то 0.05%, что
имхо уже ерунда.
Параллельно как-то сам собой установился новый рекорд на размер процедуры
Encode - всего 5 строчек. 8-)"

Это о том, что оптимизированный вариант быстрее сбрасывает биты, когда они не меняются у low и low+range-1.
А значит, позволяет продолжить вычисления с большей точностью (интервал уже нормализован), по сравнению с тем, как это было бы с циклом,
где в условии фигурирует только range <= MIN_RANGE.